var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import penpal from 'penpal';
import EventEmitter from 'eventemitter3';
import moment from 'moment';
import isBuffer from 'is-buffer';
import version from './version';
import AuthereumProvider from './AuthereumProvider';
import { defaultConfig } from './config';
import { wait, debounce, throttle, uuidv4, getQueryParamValue, removeQueryParam, updateQueryParams, replaceWindowUrl, browserInfo } from './utils';
// Serialize object for postMessage to iframe.
// Converts references to values.
const serializeMessageObj = (obj) => {
    const tx = {};
    for (let k in obj) {
        let v = obj[k];
        if (typeof v === 'object' && v.toString === 'function') {
            v = v.toString('hex');
        }
        tx[k] = v;
    }
    return tx;
};
const defaultIframeStyle = {
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    zIndex: 1
};
// This is a placeholder notify object stub until notifier script url is
// injected into page after iframe is loaded.
const defaultNotifier = {
    notify: (type, message) => {
        console.log(type, message);
        return {
            dismiss: () => {
                // noop
            }
        };
    }
};
export default class Authereum extends EventEmitter {
    constructor(config) {
        super();
        this._debug = !!getQueryParamValue('debug');
        this._notifier = defaultNotifier;
        this._iframeReady = false;
        this._configReady = false;
        this._iframeConnecting = null;
        this._cacheReady = false;
        this._readyEmitted = false;
        this._widgetEnabled = false;
        this._iframeStyle = defaultIframeStyle;
        this._notificationIframeStyle = defaultIframeStyle;
        this._blockedPopupRedirect = true;
        this._heartbeatStarted = false;
        this._backoffTimeout = 1;
        this._userConfig = null;
        this._asymmetricEncryptionKey = null;
        this._authereumQueryParams = {};
        this._injectedElements = [];
        this._notificationsMap = {};
        this._destroyed = false;
        // NOTE: keep this sync
        this._init = (config) => {
            if (typeof config === 'string') {
                let network = config;
                this._networkName = (network || '').trim().toLowerCase();
                if (['mainnet', 'ropsten', 'rinkeby', 'kovan', 'goerli'].includes(this._networkName)) {
                    this._xsUri = defaultConfig.xsUri(this._networkName);
                }
                else if (config === 'localhost') {
                    this._xsUri = 'http://localhost:3002';
                    this._networkName = 'kovan';
                }
                else {
                    throw new Error('Unsupported network');
                }
            }
            else {
                config = config || {};
                this._networkName = config.networkName || 'mainnet';
                this._xsUri = config.xsUri || defaultConfig.xsUri(this._networkName);
                this._apiKey = config.apiKey;
            }
            if (config.redirectUri) {
                this._redirectUri = config.redirectUri;
            }
            else {
                this._redirectUri = window.location.href;
            }
            this._iframeStyle = {
                width: 0,
                height: 0,
                top: 0,
                left: 0,
                zIndex: 0
            };
            this._redirectUri = this._redirectUri || window.location.href;
            this._provider = new AuthereumProvider(this);
            this._connectToChildIframe()
                .catch(() => {
                this._startHeartbeat(true);
            });
            this._setupCache();
            this._cacheAuthereumQueryParams();
            this._setupSigningKey();
            this._setupResizeListener();
            this._setupFocusListener();
            this._setupActionKeyListener();
            this._emitReadyEvent();
        };
        // NOTE: keep this sync
        this._setConfig = (config) => {
            if (typeof this._userConfig === 'string') {
                let network = this._userConfig;
                this._networkName = (network || '').trim().toLowerCase();
                this._userConfig = {
                    networkName: this._networkName,
                    xsUri: defaultConfig.xsUri(this._networkName)
                };
            }
            const { apiKey, apiUri, rpcUri, webUri, notifierUri, networkName, networkId, disableNotifications, blockedPopupRedirect } = this._userConfig || {};
            if (apiKey) {
                this._apiKey = apiKey;
            }
            // userConfig overrides regular config
            if (apiUri) {
                this._apiUri = apiUri;
            }
            else if (config.apiUri) {
                this._apiUri = config.apiUri;
            }
            // userConfig overrides regular config
            if (rpcUri) {
                this._rpcUri = rpcUri;
            }
            else {
                this._rpcUri = config.rpcUri;
            }
            // userConfig overrides regular config
            if (webUri) {
                this._webUri = webUri;
            }
            else if (config.webUri) {
                this._webUri = config.webUri;
            }
            // userConfig overrides regular config
            if (notifierUri) {
                this._notifierUri = notifierUri;
            }
            else if (config.notifierUri) {
                this._notifierUri = config.notifierUri;
            }
            // userConfig overrides regular config
            if (networkName) {
                this._networkName = networkName;
            }
            else if (config.networkName) {
                this._networkName = config.networkName;
            }
            // userConfig overrides regular config
            if (networkId) {
                this._networkId = networkId;
            }
            else if (config.networkId) {
                this._networkId = config.networkId;
            }
            // userConfig overrides regular config
            if (typeof disableNotifications === 'boolean') {
                this._disableNotifications = disableNotifications;
            }
            else if (typeof config.disableNotifications === 'boolean') {
                this._disableNotifications = config.disableNotifications;
            }
            // userConfig overrides regular config
            if (typeof blockedPopupRedirect === 'boolean') {
                this._blockedPopupRedirect = blockedPopupRedirect;
            }
            else if (typeof config.blockedPopupRedirect === 'boolean') {
                this._blockedPopupRedirect = config.blockedPopupRedirect;
            }
        };
        this._setupCache = () => __awaiter(this, void 0, void 0, function* () {
            yield Promise.all([
                this._cacheLoginKeyAddress(),
                this._cacheIsAuthenticated(),
                this._cacheAccountAddress()
            ]);
            this._cacheReady = true;
        });
        this._handleWindowFocus = () => {
            if (this._destroyed) {
                return;
            }
            return this._postMessageToChild({
                method: 'onWindowFocus'
            });
        };
        this._resetCache = () => __awaiter(this, void 0, void 0, function* () {
            return this._setupCache();
        });
        this._injectScript = (sourceUrl, id = '') => __awaiter(this, void 0, void 0, function* () {
            yield this._tilDomReady();
            return new Promise((resolve, reject) => {
                if (!sourceUrl) {
                    throw new Error('sourceUrl is required');
                }
                if (document.getElementById(id)) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.id = id;
                script.type = 'text/javascript';
                script.async = true;
                script.onload = () => {
                    resolve();
                };
                script.onerror = (err) => {
                    reject(err);
                };
                script.src = sourceUrl;
                this._injectedElements.push(script);
                document.getElementsByTagName('head')[0].appendChild(script);
            });
        });
        this._setupResizeListener = () => __awaiter(this, void 0, void 0, function* () {
            window.addEventListener('resize', this._handleResizeThrottled, false);
            window.addEventListener('resize', this._handleResizeDebounced, false);
        });
        this._handleActionKeyPress = (event) => {
            if (this._destroyed) {
                return;
            }
            let keyName = '';
            if (event.key === 'Escape' || event.key === 'Esc' || event.keyCode === 27) {
                keyName = 'escape';
            }
            else if (event.key === 'Enter' || event.keyCode === 13) {
                keyName = 'enter';
            }
            else if (event.key === 'ArrowLeft' || event.keyCode === 37) {
                keyName = 'left';
            }
            else if (event.key === 'ArrowUp' || event.keyCode === 38) {
                keyName = 'up';
            }
            else if (event.key === 'ArrowRight' || event.keyCode === 39) {
                keyName = 'right';
            }
            else if (event.key === 'ArrowDown' || event.keyCode === 40) {
                keyName = 'down';
            }
            if (keyName) {
                return this._postMessageToChild({
                    method: 'actionKeyPress',
                    params: keyName
                });
            }
        };
        this._handleResize = (event) => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                return;
            }
            const size = yield this._getWindowSize();
            return this._postMessageToChild({
                method: 'onResize',
                params: size
            });
        });
        this._handleResizeThrottled = throttle((event) => {
            return this._handleResize(event);
        }, 10);
        this._handleResizeDebounced = debounce((event) => {
            return this._handleResize(event);
        }, 10);
        this._cacheLoginKeyAddress = () => __awaiter(this, void 0, void 0, function* () {
            const loginKey = yield this._postMessageToChild({
                method: 'getOrCreateLoginKey'
            });
            this._cachedLoginKeyAddress = loginKey.publicAddress;
        });
        this._cacheAccountAddress = () => __awaiter(this, void 0, void 0, function* () {
            const accountAddress = yield this._postMessageToChild({
                method: 'getAccountAddress'
            });
            this._cachedAccountAddress = accountAddress;
        });
        this._cacheIsAuthenticated = () => __awaiter(this, void 0, void 0, function* () {
            const isAuthenticated = yield this._postMessageToChild({
                method: 'isAuthenticated'
            });
            this._cachedIsAuthenticated = isAuthenticated;
        });
        // NOTE: to prevent pop-ups from being blocked, there must be no awaits from
        // click to window.open, meaning value lookups must be cached before the
        // login method is called.
        this.login = throttle(() => __awaiter(this, void 0, void 0, function* () {
            yield this._tilConfigReady();
            yield this._tilReady();
            if (!this._cachedIsAuthenticated) {
                // NOTE: if not logged in to dapp, then proceed to login
                yield this._signLoginKeyRequest(this._cachedLoginKeyAddress);
                return this.getAuthenticatedAccount();
            }
            else {
                // only show one already logged in notification at a time
                if (!this._notificationsMap['loggedIn']) {
                    this._postMessageToChild({
                        method: 'notification',
                        params: {
                            type: 'success',
                            message: 'You are logged into Authereum',
                            timeout: 5e3
                        }
                    });
                    this._notificationsMap['loggedIn'] = true;
                    setTimeout(() => {
                        this._notificationsMap['loggedIn'] = null;
                    }, 5e3);
                }
            }
            // await first
            const account = yield this.getAuthenticatedAccount();
            return account;
        }), 250);
        this.authenticate = () => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.authenticate()` is deprecated. Use `authereum.login()` instead.');
            return this.login();
        });
        this.isAuthenticated = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'isAuthenticated'
            }));
        });
        this.logout = () => __awaiter(this, void 0, void 0, function* () {
            const res = yield this._postMessageToChild({
                method: 'logout'
            });
            yield this._resetCache();
            this.emit('logout', {});
            return res;
        });
        this.getAuthenticatedAccount = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getAuthenticatedAccount'
            }));
        });
        this.getDappKey = () => {
            return this._handleError(this._postMessageToChild({
                method: 'getLoginKey'
            }));
        };
        this.getLoginKey = () => {
            console.warn('Deprecation notice: `authereum.getLoginKey()` is deprecated. Use `authereum.getDappKey()` instead.');
            return this.getDappKey();
        };
        this.signMessage = throttle((message) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'signMessage',
                params: message
            }));
        }), 250);
        this.signPersonalMessage = throttle((message) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'signPersonalMessage',
                params: message
            }));
        }), 250);
        this.signWithDappKey = throttle((message) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.signWithDappKey()` is deprecated. Use `authereum.signMess()` instead.');
            return this.signMessage(message);
        }), 250);
        this.signWithLoginKey = throttle((message) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.signWithLoginKey()` is deprecated. Use `authereum.signWithDappKey()` instead.');
            return this.signWithDappKey(message);
        }), 250);
        this.signTypedMessage = throttle((message) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'signTypedMessage',
                params: message
            }));
        }), 250);
        this.signTypedMessageWithDappKey = throttle((message) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum.signTypedMessageWithDappKey()` is deprecated. Use `authereum.signTypedMessage()` instead.');
            return this.signTypedMessage(message);
        }), 250);
        this.signMessageWithAdminKey = throttle((message) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecated: `authereum.signMessageWithAdminKey()` is deprecated. Use `authereum.signMessageWithSigningKey()` instead.');
            return null;
        }), 250);
        this.signMessageWithSigningKey = throttle((message) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'signMessageWithSigningKey',
                params: message
            }));
        }), 250);
        this.getSigningKeyAddress = (message) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getSigningKeyAddress'
            }));
        });
        this.getLoginKeyAuthSignature = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getLoginKeyAuthSignature'
            }));
        });
        this.getLoginKeyRestrictionsData = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getLoginKeyRestrictionsData'
            }));
        });
        this.getAccountAddress = () => __awaiter(this, void 0, void 0, function* () {
            // required so it waits for login key to be set
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'getAccountAddress'
            }));
        });
        this.getBalance = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getBalance'
            }));
        });
        this.getRpcUri = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilConfigReady();
            return this._rpcUri;
        });
        this.getNetworkId = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getNetworkId'
            }));
        });
        this.getNetworkName = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getNetworkName'
            }));
        });
        this.getProvider = () => {
            return this._provider;
        };
        this._handleError = (promise) => __awaiter(this, void 0, void 0, function* () {
            return promise
                .catch((err) => {
                // NOTE: emit errors but don't throw notification here.
                this.emit('error', err);
                // NOTE: rethrow error to let dapps handle error
                throw err;
            });
        });
        this.signTransaction = throttle((tx) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'signTransaction',
                params: serializeMessageObj(tx)
            }));
        }), 250);
        this.signTransactionWithLoginKey = throttle((tx) => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecated: `authereum.signTransactionWithLoginKey()` is deprecated. Use `authereum.signTransaction()` instead.');
            return this.signTransaction(tx);
        }), 250);
        this.sendTransaction = throttle((userTransaction) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'sendTransaction',
                params: serializeMessageObj(userTransaction)
            }));
        }), 250);
        this.sendTransactionBatch = throttle((userTransactions) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'sendTransactionBatch',
                params: userTransactions.map(serializeMessageObj)
            }));
        }), 250);
        this.estimateGasBatch = throttle((userTransactions) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'estimateGasBatch',
                params: userTransactions.map(serializeMessageObj)
            }));
        }), 250);
        this.isReady = () => {
            return this._iframeReady && this._cacheReady;
        };
        this.updateConfig = (config) => {
            this._userConfig = config;
            this._setConfig(config);
        };
        this.getConfig = () => {
            return {
                apiUri: this._apiUri,
                rpcUri: this._rpcUri,
                webUri: this._webUri,
                xsUri: this._xsUri,
                networkName: this._networkName,
                networkId: this._networkId,
                disableNotifications: this._disableNotifications
            };
        };
        this.showWidget = (enabled = true) => __awaiter(this, void 0, void 0, function* () {
            if (!enabled) {
                this._widgetEnabled = false;
                return this._postMessageToChild({
                    method: 'hideWidget'
                });
            }
            this._widgetEnabled = true;
            return this._postMessageToChild({
                method: 'showWidget'
            });
        });
        this.hideWidget = () => __awaiter(this, void 0, void 0, function* () {
            this._widgetEnabled = false;
            return this._postMessageToChild({
                method: 'hideWidget'
            });
        });
        this.widgetEnabled = () => {
            return this._widgetEnabled;
        };
        this.addFunds = (opts) => {
            return this._postMessageToChild({
                method: 'addFunds',
                params: opts
            });
        };
        this._openUrl = (opts = {}) => {
            const { url, newWindow } = opts;
            if (newWindow) {
                window.open(url, '_blank');
            }
            else {
                window.location.href = url;
            }
        };
        this._tilIframeReady = () => __awaiter(this, void 0, void 0, function* () {
            if (!this._iframeReady) {
                yield wait(100);
                return this._tilIframeReady();
            }
            yield wait(100);
            return true;
        });
        this._tilConfigReady = () => __awaiter(this, void 0, void 0, function* () {
            if (!this._configReady) {
                yield wait(100);
                return this._tilConfigReady();
            }
            yield wait(100);
            return true;
        });
        this._tilReady = () => __awaiter(this, void 0, void 0, function* () {
            if (!this.isReady()) {
                yield wait(100);
                return this._tilReady();
            }
            yield wait(100);
            return true;
        });
        this._emitReadyEvent = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            if (this._readyEmitted)
                return;
            this._readyEmitted = true;
            this.emit('ready', {});
        });
        this._connectToChildIframe = () => __awaiter(this, void 0, void 0, function* () {
            if (this._iframeConnecting) {
                return this._iframeConnecting;
            }
            this._iframeReady = false;
            this._iframeConnecting = true;
            const iframe = yield this._getOrCreateMainIframe();
            this._iframeConnection = penpal.connectToChild({
                iframe,
                timeout: 60e3,
                methods: {
                    // NOTE: the postMessage penpal method should be the only method that
                    // exists.
                    postMessage: (data) => {
                        return this._handlePostMessage(data);
                    }
                }
            });
            this._iframeConnecting = new Promise((resolve, reject) => {
                let timedout = false;
                const timer = setTimeout(() => {
                    if (!this._iframeReady) {
                        timedout = true;
                        this._iframeConnecting = null;
                        reject(new Error('timedout'));
                    }
                }, 3e3);
                this._iframeConnection.promise.then((child) => {
                    clearTimeout(timer);
                    if (timedout) {
                        return;
                    }
                    this._iframeReady = true;
                    this._childIframeConnection = child;
                    this._startHeartbeat();
                    this._iframeConnecting = null;
                    resolve();
                })
                    .catch((err) => {
                    clearTimeout(timer);
                    if (timedout) {
                        return;
                    }
                    reject(err);
                });
            });
            return this._iframeConnecting;
        });
        this._startHeartbeat = (reconnect = false) => {
            if (!this._heartbeatStarted) {
                this._heartbeat(reconnect);
                this._heartbeatStarted = true;
            }
        };
        this._heartbeat = (reconnect = false) => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                return;
            }
            yield wait(2e3);
            try {
                if (reconnect) {
                    yield this._connectToChildIframe();
                    this._backoffTimeout = 1;
                    return this._heartbeat();
                }
                yield this._ping();
            }
            catch (err) {
                // reconnect on destroyed connection error or ping timeout error
                if (/destroy|timedout/gi.test(err.message)) {
                    yield wait(this._backoffTimeout * 1e3);
                    // exponential backoff
                    this._backoffTimeout = this._backoffTimeout << 1;
                    return this._heartbeat(true);
                }
            }
            return this._heartbeat();
        });
        this._ping = () => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let timedout = false;
                const timer = setTimeout(() => {
                    timedout = true;
                }, 5e3);
                this._postMessageToChild({
                    method: 'ping'
                }).then((pong) => {
                    clearTimeout(timer);
                    if (timedout) {
                        reject(new Error('timedout'));
                        return;
                    }
                    if (pong !== 'pong') {
                        reject(new Error('Invalid response'));
                        return;
                    }
                    resolve(pong);
                })
                    .catch(err => {
                    reject(err);
                });
            });
        });
        this._injectIframe = (input) => {
            const { id, url } = input;
            let parentUrl = window.location.href;
            try {
                parentUrl = parent.document.URL;
            }
            catch (err) {
                // noop
            }
            const srcUrl = updateQueryParams({ url: parentUrl }, url);
            const iframe = document.createElement('iframe');
            iframe.id = id;
            iframe.src = srcUrl;
            if (['Safari', 'Firefox'].includes(browserInfo().browser)) {
                iframe.setAttribute('sandbox', 'allow-storage-access-by-user-activation allow-scripts allow-same-origin');
            }
            iframe.style.position = 'fixed';
            iframe.style.bottom = '0';
            iframe.style.right = '0';
            iframe.style.width = '0';
            iframe.style.height = '0';
            iframe.style.border = '0';
            iframe.style.background = 'transparent';
            iframe.style.zIndex = `${defaultIframeStyle.zIndex}`;
            iframe.setAttribute('frameborder', '0');
            iframe.setAttribute('scrolling', 'no');
            if (this._debug) {
                iframe.style.outline = '1px solid red';
            }
            this._injectedElements.push(iframe);
            return iframe;
        };
        this._getConfigFromChild = () => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'getConfig'
            });
        });
        this._postVersionToChild = () => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'version',
                params: this.version()
            });
        });
        this._postConfigToChild = () => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'config',
                params: {
                    apiKey: this._apiKey,
                    disableNotifications: this._disableNotifications
                }
            });
        });
        this._loadAsymmetricEncryptionKeyFromChild = () => __awaiter(this, void 0, void 0, function* () {
            this._asymmetricEncryptionKey = yield this._postMessageToChild({
                method: 'getAsymmetricEncryptionKey'
            });
        });
        this._postMessageToChild = (data) => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                throw new Error('Authereum instance destroyed.');
            }
            yield this._tilIframeReady();
            return this._handleError(this._childIframeConnection.postMessage(data));
        });
        this._handleChildLogoutEvent = () => __awaiter(this, void 0, void 0, function* () {
            yield this._resetCache();
            this.emit('logout', {});
        });
        this._handleChildDappKeyExpired = (loginKeyAddress) => __awaiter(this, void 0, void 0, function* () {
            if (loginKeyAddress === this._cachedLoginKeyAddress) {
                yield this._resetCache();
                this.emit('dappKeyExpired', loginKeyAddress);
                this.emit('logout');
            }
        });
        this._handlePostMessage = (data) => {
            try {
                const { method, params } = data;
                switch (method) {
                    case 'onError':
                        const err = params;
                        this.emit('error', err);
                        this._notifier.notify({
                            type: 'error',
                            message: err.message
                        });
                        return;
                    case 'onLogout':
                        return this._handleChildLogoutEvent();
                    case 'onDappKeyExpired':
                        return this._handleChildDappKeyExpired(params);
                    case 'login':
                        return this.login();
                    case 'setWidgetPosition':
                        // const position = params
                        // const { x, y } = position
                        // this.iframeStyle.left = x
                        // this.iframeStyle.top = y
                        // this._refreshWidget()
                        return;
                    case 'setWidgetSize': {
                        const size = params;
                        const { width, height } = size;
                        this._iframeStyle.width = width;
                        this._iframeStyle.height = height;
                        return this._refreshWidget();
                    }
                    case 'setWidgetStyle': {
                        const style = params;
                        for (let key in style) {
                            this._iframeStyle[key] = style[key];
                        }
                        return this._refreshWidget();
                    }
                    case 'setNotificationWidgetSize': {
                        const size = params;
                        const { width, height } = size;
                        this._notificationIframeStyle.width = width;
                        this._notificationIframeStyle.height = height;
                        return this._refreshNotificationWidget();
                    }
                    case 'setNotificationWidgetStyle': {
                        const style = params;
                        for (let key in style) {
                            this._notificationIframeStyle[key] = style[key];
                        }
                        return this._refreshNotificationWidget();
                    }
                    case 'getWindowSize':
                        return this._getWindowSize();
                    case 'hideWidget':
                        return this.hideWidget();
                    case 'log':
                        return this._handlePostMessageLog(params);
                    case 'openUrl':
                        return this._openUrl(params);
                    default:
                        break;
                }
            }
            catch (err) {
                // noop
            }
        };
        this._handlePostMessageLog = (data) => {
            let { type, message } = data;
            if (!type) {
                type = 'log';
            }
            console[type](message);
        };
        this._getWindowSize = () => {
            return {
                width: this._getWindowWidth(),
                height: this._getWindowHeight()
            };
        };
        this._getWindowWidth = () => {
            return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        };
        this._getWindowHeight = () => {
            return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        };
        // public _setIframePositionTop = (y: number) => {
        // if (!this._iframe) return
        // this._iframe.style.top = `${y}px`
        // }
        this._setIframePositionLeft = (x) => {
            if (!this._iframe)
                return;
            this._iframe.style.left = `${x}px`;
        };
        this._setIframeWidth = (width) => {
            if (!this._iframe)
                return;
            this._iframe.style.width = `${width}px`;
        };
        this._setIframeHeight = (height) => {
            if (!this._iframe)
                return;
            this._iframe.style.height = `${height}px`;
        };
        this._refreshWidget = () => {
            const { top, left, width, height, zIndex } = this._iframeStyle;
            if (!this._iframe)
                return;
            // this._setIframePositionTop(top)
            // this._setIframePositionLeft(left)
            this._setIframeWidth(width);
            this._setIframeHeight(height);
            this._iframe.style.zIndex = `${zIndex || 0}`;
        };
        this._refreshNotificationWidget = () => {
            const { top, left, width, height, zIndex } = this._notificationIframeStyle;
            this._notificationIframe.style.width = `${width}px`;
            this._notificationIframe.style.height = `${height}px`;
            this._notificationIframe.style.zIndex = `${zIndex || 0}`;
        };
        this._loginKeyExists = () => __awaiter(this, void 0, void 0, function* () {
            return !!(yield this.getLoginKey());
        });
        this._accountAddressExists = () => __awaiter(this, void 0, void 0, function* () {
            return !!(yield this.getAccountAddress());
        });
        this._getAccountAdminKeyNonce = () => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'getAccountAuthKeyNonce'
            }));
        });
        this._getAccountAuthKeyNonce = () => __awaiter(this, void 0, void 0, function* () {
            console.warn('Deprecation notice: `authereum._getAccountAuthKeyNonce()` is deprecated. Use `authereum._getAccountAdminKeyNonce()` instead.');
            return this._getAccountAdminKeyNonce();
        });
        this._executeLoginKeyMetaTx = (tx) => __awaiter(this, void 0, void 0, function* () {
            return this._handleError(this._postMessageToChild({
                method: 'executeLoginKeyMetaTx',
                params: serializeMessageObj(tx)
            }));
        });
        this._loadLoginKey = (loginKey) => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'loadLoginKey',
                params: loginKey
            }));
        });
        this._getOrCreateLoginKey = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            return this._handleError(this._postMessageToChild({
                method: 'getOrCreateLoginKey'
            }));
        });
        this._getAuthenticateUri = (loginKeyAddress) => {
            const encryptionKey = this._asymmetricEncryptionKey;
            // NOTE: slk = sign login key
            return this._webUri + '/?slk=' + encodeURIComponent(JSON.stringify({
                loginKey: {
                    publicAddress: loginKeyAddress,
                    // Convert to UTC to avoid local machine timezones
                    expiresAt: moment().add(1, 'month').utc().unix()
                },
                encryptionKey
            })) + '&redirect_uri=' + this._redirectUri;
        };
        this._getSignWithAdminKeyUri = (message) => {
            if (isBuffer(message)) {
                message = `0x${message.toString('hex')}`;
            }
            // NOTE: sm = sign message
            return this._webUri + '/?sm=' + encodeURIComponent(JSON.stringify({
                message
            })) + '&redirect_uri=' + this._redirectUri;
        };
        this._openPopupOrRedirect = (url) => __awaiter(this, void 0, void 0, function* () {
            this.emit('openPopup', {});
            const child = window.open(url, 'Authereum', `toolbar=no,
      location=no,
      status=no,
      menubar=no,
      scrollbars=no,
      resizable=no,
      width=470,
      height=640`);
            const isBlocked = (child === null || child === undefined);
            if (isBlocked && !this._blockedPopupRedirect) {
                const err = new Error('Disable popup blocker and try again');
                this._notifier.notify({
                    type: 'error',
                    message: err.message,
                    timeout: 5000
                });
                throw err;
            }
            else if (isBlocked) {
                this.emit('popupBlocked');
                // NOTE: if window is blocked then resort to redirect
                window.location.href = url;
                return;
            }
            child.focus();
            return new Promise((resolve, reject) => {
                const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                    if (child.closed) {
                        cleanUp();
                        const err = new Error('Window closed');
                        this.emit('error', err);
                        this.emit('closePopup', {});
                        reject(err);
                    }
                }), 250);
                const timeout = setTimeout(() => {
                    cleanUp();
                    child.close();
                    doneWithError(new Error('Timedout'));
                }, 10 * 60 * 1000);
                const cleanUp = () => {
                    clearInterval(interval);
                    clearTimeout(timeout);
                    this.emit('closePopup', {});
                };
                const doneWithError = (err) => {
                    cleanUp();
                    this.emit('error', err);
                    reject(err);
                };
                const done = (result = {}) => {
                    cleanUp();
                    resolve(result);
                };
                window.addEventListener('message', (event) => __awaiter(this, void 0, void 0, function* () {
                    if (event.origin.includes(this._webUri)) {
                        // this event tells parent to close child popup
                        if (event.data.close) {
                            child.close();
                            done();
                        }
                        if (event.data.login) {
                            done({ success: true });
                            this.emit('login', {});
                            this._cachedIsAuthenticated = true;
                            if (event.data.encryptedSigningKey) {
                                yield this._loadSigningKey(event.data.encryptedSigningKey);
                            }
                            this._logAnalyticsEvent({
                                eventType: 'logged_in_dapp',
                                properties: {
                                    dapp_url: window.location.href
                                }
                            });
                            if (this._redirectUri !== window.location.href) {
                                window.location.href = this._redirectUri;
                            }
                        }
                        if (event.data.result) {
                            done(event.data.result);
                            if (this._redirectUri !== window.location.href) {
                                window.location.href = this._redirectUri;
                            }
                        }
                        if (event.data.error) {
                            doneWithError(new Error(event.data.error));
                            if (this._redirectUri !== window.location.href) {
                                window.location.href = this._redirectUri;
                            }
                        }
                    }
                }));
            });
        });
        this._signLoginKeyRequest = (publicAddress) => __awaiter(this, void 0, void 0, function* () {
            const url = this._getAuthenticateUri(publicAddress);
            return this._openPopupOrRedirect(url);
        });
        this._tilDomReady = () => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                if (document.readyState !== 'loading') {
                    resolve();
                }
                else {
                    document.addEventListener('DOMContentLoaded', () => resolve());
                }
            });
        });
        // keep both static and normal version methods
        this.version = () => {
            return version;
        };
        this.isAuthenticatedSync = () => {
            return this._cachedIsAuthenticated;
        };
        this.getTransactionReceipt = (txHash) => {
            return this._handleError(this._postMessageToChild({
                method: 'getTransactionReceipt',
                params: txHash
            }));
        };
        this.waitForTransactionReceipt = (txHash) => {
            return this._handleError(this._postMessageToChild({
                method: 'waitForTransactionReceipt',
                params: txHash
            }));
        };
        this.hasRecoveryEnabled = () => {
            return this._handleError(this._postMessageToChild({
                method: 'hasRecoveryEnabled'
            }));
        };
        this.isContractDeployed = (accountAddress) => {
            return this._handleError(this._postMessageToChild({
                method: 'isContractDeployed',
                params: accountAddress
            }));
        };
        this._loadSigningKey = (signingKey) => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'loadSigningKey',
                params: signingKey
            });
        });
        this._logAnalyticsEvent = (input) => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'logAnalyticsEvent',
                params: input
            });
        });
        this._setupSigningKey = () => __awaiter(this, void 0, void 0, function* () {
            yield this._tilReady();
            const encryptedSigningKey = this._authereumQueryParams['encryptedSigningKey'];
            if (encryptedSigningKey) {
                const success = yield this._loadSigningKey(encryptedSigningKey);
                if (success) {
                    try {
                        localStorage.removeItem('_authereum');
                    }
                    catch (err) {
                        // noop
                    }
                }
            }
        });
        this._cacheAuthereumQueryParams = () => __awaiter(this, void 0, void 0, function* () {
            try {
                const param = getQueryParamValue('_authereum');
                if (param) {
                    this._authereumQueryParams = JSON.parse(param);
                    try {
                        localStorage.setItem('_authereum', btoa(JSON.stringify(this._authereumQueryParams)));
                    }
                    catch (err) {
                        // noop
                    }
                    const newUrl = removeQueryParam('_authereum');
                    replaceWindowUrl(newUrl);
                }
                else {
                    try {
                        // load from local storage cache if exists.
                        // this local storage is cleared after connection.
                        let cached = localStorage.getItem('_authereum');
                        if (cached) {
                            this._authereumQueryParams = JSON.parse(atob(cached));
                        }
                    }
                    catch (err) {
                        // noop
                    }
                }
            }
            catch (err) {
                // noop
            }
        });
        this.destroy = () => __awaiter(this, void 0, void 0, function* () {
            if (this._destroyed) {
                console.warn('Authereum instance already destroyed.');
                return true;
            }
            try {
                if (this._iframeReady) {
                    yield this._postMessageToChild({
                        method: 'destroy'
                    });
                }
            }
            catch (err) {
                console.error(err);
            }
            for (let i = 0; i < this._injectedElements.length; i++) {
                const element = this._injectedElements[i];
                try {
                    element.remove();
                }
                catch (err) {
                    console.error(err);
                }
            }
            const elements = document.querySelectorAll('[id*="authereum"]');
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                try {
                    element.remove();
                }
                catch (err) {
                    console.error(err);
                }
            }
            this._iframeReady = false;
            this._destroyed = true;
            console.warn('Authereum instance destroyed.');
            this._teardownEventListeners();
            this.emit('destroy', {});
            return true;
        });
        this.isDestroyed = () => {
            return this._destroyed;
        };
        this.getAddressQrCodeDataUri = (address) => __awaiter(this, void 0, void 0, function* () {
            return this._postMessageToChild({
                method: 'getAddressQrCodeDataUri',
                params: {
                    address
                }
            });
        });
        this._loadNotificationsIframe = (url) => __awaiter(this, void 0, void 0, function* () {
            const id = `authereum__x-notification-iframe--${uuidv4()}`;
            this._notificationIframe = this._injectIframe({ id, url });
            this._notificationIframe.style.top = '0';
            this._notificationIframe.style.right = '0';
            yield this._tilDomReady();
            document.body.appendChild(this._notificationIframe);
        });
        this._setDebug = (enabled) => __awaiter(this, void 0, void 0, function* () {
            this._debug = enabled;
            if (this._debug) {
                this._iframe.style.outline = '1px solid red';
                this._notificationIframe.style.outline = '1px solid red';
            }
            else {
                this._iframe.style.outline = '0';
                this._notificationIframe.style.outline = '0';
            }
        });
        this._userConfig = config;
        this._init(config);
    }
    _setupFocusListener() {
        window.addEventListener('focus', this._handleWindowFocus, false);
    }
    _setupActionKeyListener() {
        window.addEventListener('keydown', this._handleActionKeyPress, false);
    }
    _teardownEventListeners() {
        window.removeEventListener('resize', this._handleResizeThrottled, false);
        window.removeEventListener('resize', this._handleResizeDebounced, false);
        window.removeEventListener('focus', this._handleWindowFocus, false);
        window.removeEventListener('keydown', this._handleActionKeyPress, false);
    }
    _getOrCreateMainIframe() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._iframe) {
                if (this._iframeConnection) {
                    this._iframeConnection.destroy();
                }
                this._iframe.remove();
            }
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const id = `authereum__x-iframe--${uuidv4()}`;
                this._iframe = this._injectIframe({ id, url: this._xsUri });
                resolve(this._iframe);
                yield this._tilDomReady();
                document.body.appendChild(this._iframe);
                this._iframe.onload = () => {
                    this._postVersionToChild();
                    this._loadAsymmetricEncryptionKeyFromChild();
                    this._getConfigFromChild()
                        .then((config) => {
                        this._loadNotificationsIframe(config.notifierIframeUri);
                        this._setConfig(config);
                        this._postConfigToChild();
                        this._configReady = true;
                        this.emit('iframeReady', {});
                    });
                };
            }));
        });
    }
}
// keep both static and normal version methods
Authereum.version = () => {
    return version;
};
if (typeof window !== 'undefined') {
    window.Authereum = Authereum;
}
